# Plan
- Need to determine design and read thru that
- Need to determine what I want within the system and how to accomplish that from top downwards
- Want to develop full bootloader, kernel, and userland
- Also need to determine type of OS, whether want to start with small ephermal machines for lambda operations or ad-hoc tasks
- Also want to gear something towards efficient development environment

## Development System
- Would need good editor, hopefully make use of existing packages like Neovim, find a way to package for this, but also write a default editor with Vim bindings
- Would also want simple & performant browser
- Need terminal emulator with session multiplexing built-in
- Tiling WM
- Also have ability to eventually consume media, and capture screen
- Would like to match design of NixOS and declaratively express system
- Also need to design proper package manager

## OS
- Software controlling the operation of a computer system and its resources
- Should be capable of loading an executing user programs and providing standardized (hardware-independent) I/O interface for them
- Major functions of OS include
    - Managing memory and other systems resources
    - Imposing security and access poslicies
    - Scheduling and multiplexing processes and threads
    - Launching and closing user programs dynamically
    - Providing a basic UI and API

## Kernel
- Enables other programs to execute, handles events generated by hardware (called interrupts) and software (system calls) and manages access to resources
- Hardware event handlers (interrupt handlers) will get the number of key inputted and convert it to the corresponding character stored in a buffer so some program can receive it
- System calls are initiated by user-level programs, for opening files, starting other programs, etc, each syscall handler will have to check whether the arguments passed are valid, then perform the internal operation to complete the requeste
- Most user programs do not directly issue syscalls (except for asm programs) but instead use a standard library which does the job of formatting arguments as required by the kernel and generating the syscall
    - C function fopen() eventually calls a kernel function that opens the file
- The kernel usually defines some abstractions like files, processes, sockets, directories, etc, which correspond to an internal state it remembers about last operations so that a program may issue a session of operation more efficiently

## Shell
- Program integrated in an OS distribution that offers humans an interface with the computer
    - Allows user to select a program to be started, and optionally gives it session-specific arguments
    - Allows trivial operation on the local storage like listing the content of directories, moving and copying files across the system
- In order to complete these actions, shell may have to issue syscalls to open files or create them if they don't exist, and read the content from a file and write it into another, and close the files, and write something to standard output
- Shell may be used by programs that want to start other programs but do not want to do this themselves
    - Auto-Completion, pressing a key, word user is typing will be completed to a valid shell command, a file, directory, or something else, pressing the key multiple times cycles through other completion possibilities
    - Character Insertion: user can move around in what they entered with arrow keys, when typing new characters in the middle of a sentence, characters will be inserted
    - Shell History: By using the up and down arrows, user can scroll through previous input
    - Scrolling: When there are more lines than the cnosole is high, save output in a buffer and allow user to scroll up and down in the console
    - Scripting: Some shells have custom scripting languages

## GUI
- Must be able to:
    - Catch user input events (keyboard, mouse, etc) and dispatch them to the proper object
    - Update the internal information of what is to be displayed where on the screen, determining which part of the screen need to be redrawn
    - Update the visible screen contents, redrawing the necessary parts
    - Do this in a way that feels natural, intuitive, and responsive to the user

## DE, WM, Widget Library
- DE is a graphical shell providing the functional environment for all lower-level features
- WM is responsible for window organization of running programs, resizing/closing gadgets, window borders, and scrollbars
- Subsystem that does drawing of control elements, rendering documents on screen, etc

## Required Knowledge
- Assembly
- UNIX experience
- Should review [code management practices](https://wiki.osdev.org/Code_Management)

## Common Mistakes
- Kernel Image
    - Booting Problems
        - Reason for booting problems is frequently that too few sectors are fetched from disk, should adjust the amount of sectors fetched from disk or have the  loader/second stage loader parse the file system

## TODOs
- Selecting a DE
    - Need to select an assembler for converting assembly language to machine code
- Cross-compiler is required
- Organize plans
- MacOS
    - Need a loopback device for MacOS
- [Testing](https://wiki.osdev.org/Testing)
- Protecting Code
    - Should review JJ for VCS
- Should review [boot sequence](https://wiki.osdev.org/Boot_Sequence) and kernel design
- 
